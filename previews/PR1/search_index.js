var documenterSearchIndex = {"docs":
[{"location":"#Folds.jl-1","page":"Folds.jl","title":"Folds.jl","text":"","category":"section"},{"location":"#","page":"Folds.jl","title":"Folds.jl","text":"Folds\nFolds.fold\nFolds.Scheduler\nFolds.foldl","category":"page"},{"location":"#Folds","page":"Folds.jl","title":"Folds","text":"Folds: sequential, threaded, and distributed fold interface for Julia\n\nFolds.jl provides a unified interface for sequential, threaded, and distributed folds.\n\njulia> using Folds\n\njulia> fold(+, 1:10; threaded = true)\n55\n\njulia> sum(1:10, Folds.Scheduler(distributed = true))\n55\n\n\n\n\n\n","category":"module"},{"location":"#Folds.fold","page":"Folds.jl","title":"Folds.fold","text":"fold(rf, [xf,] collection; [init], scheduler_options...)\nfold(rf, [xf,] collection, scheduler; [init])\n\nGeneric entry point for various fold implementations.\n\nSee Folds.Scheduler for how to construct scheduler. Keyword arguments scheduler_options are passed Folds.Scheduler.\n\nKeyword Arguments\n\ninit: An initial value fed to the first argument to reducing step function step.\nsequential::Union{Val{true}, Val{false}, Bool} = false: Whether or not to use left fold.\ndistributed::Union{Val{true}, Val{false}, Bool} = false: Whether or not to use Distributed.jl.\nthreaded::Union{Val{true}, Val{false}, Bool} = !sequential: Whether or not to use multi-threading.\nordered::Union{Val{true}, Val{false}, Bool} = true: Whether or not to respect order; if false, assume that the reducing step function is commutative (and associative).\nsimd::Union{Val{true}, Val{false}, Val{:ivdep}, Bool, Symbol} = false: Whether or not to use SIMD.\n\nExamples\n\njulia> using Folds\n\njulia> xs = 1:10;\n\njulia> fold(+, xs)  # DWIM (threaded)\n55\n\njulia> fold(+, xs; sequential = true, simd = true)\n55\n\njulia> fold(+, xs; threaded = true)\n55\n\njulia> fold(+, xs; distributed = true)  # `threaded = true` implied\n55\n\njulia> fold(+, xs; distributed = true, threaded = false)\n55\n\njulia> fold(+, xs, Folds.Scheduler(distributed = true, threaded = false))  # equivalent\n55\n\n\n\n\n\n","category":"function"},{"location":"#Folds.Scheduler","page":"Folds.jl","title":"Folds.Scheduler","text":"Folds.Scheduler(; sequential, threaded, distributed, ordered, simd, kwargs...)\n\nSchedule how folds are executed.  See fold.\n\nCurrently, the default is threaded = true.  It is planned to detect parallelizability by assuming the purity of user-defined functions. Pass sequential = true or use Folds.foldl for sequential fold.\n\nKeyword Arguments\n\nsequential::Union{Val{true}, Val{false}, Bool} = false: Whether or not to use left fold.\ndistributed::Union{Val{true}, Val{false}, Bool} = false: Whether or not to use Distributed.jl.\nthreaded::Union{Val{true}, Val{false}, Bool} = !sequential: Whether or not to use multi-threading.\nordered::Union{Val{true}, Val{false}, Bool} = true: Whether or not to respect order; if false, assume that the reducing step function is commutative (and associative).\nsimd::Union{Val{true}, Val{false}, Val{:ivdep}, Bool, Symbol} = false: Whether or not to use SIMD.\n\n\n\n\n\n","category":"type"},{"location":"#Folds.foldl","page":"Folds.jl","title":"Folds.foldl","text":"Folds.foldl(rf, [xf,] collection; [init, simd])\nFolds.reduce(rf, [xf,] collection; [init, simd, basesize])\n\nLeft fold and threaded reduce based on Transducers.jl.\n\nArguments\n\nrf: A reducing step function (acc, x) -> acc′.\nxf::Transducer: A transducer.\ncollection: An array, dictionary, iterator, etc.\ninit: An initial value fed to the first argument to reducing step function step.  This argument can be omitted for well know binary operations like + or *.  Supported binary operations are listed in InitialValues.jl documentation.\nsimd: If true or :ivdep, enable SIMD using Base.@simd.  If :ivdep, use @simd ivdep for ... end variant.  Read Julia manual of Base.@simd to understand when it is appropriate to use this option.  This option has no effect if false (default).\nbasesize::Integer = amount(reducible) ÷ nthreads(): A size of chunk in reducible that is processed by each worker.  A smaller size may be required when:\ncomputation time for processing each item fluctuates a lot\ncomputation can be terminated by reduced API.\n\n\n\n\n\n","category":"function"}]
}
